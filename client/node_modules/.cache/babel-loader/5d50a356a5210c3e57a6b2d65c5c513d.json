{"ast":null,"code":"'use strict';\n\nvar utils = require('./utils');\n\nvar debug = require('./debug');\n\nvar RedisClient = require('../').RedisClient;\n\nvar Command = require('./command');\n\nvar noop = function () {};\n/**********************************************\nAll documented and exposed API belongs in here\n**********************************************/\n// Redirect calls to the appropriate function and use to send arbitrary / not supported commands\n\n\nRedisClient.prototype.send_command = RedisClient.prototype.sendCommand = function (command, args, callback) {\n  // Throw to fail early instead of relying in order in this case\n  if (typeof command !== 'string') {\n    throw new TypeError('Wrong input type \"' + (command !== null && command !== undefined ? command.constructor.name : command) + '\" for command name');\n  }\n\n  command = command.toLowerCase();\n\n  if (!Array.isArray(args)) {\n    if (args === undefined || args === null) {\n      args = [];\n    } else if (typeof args === 'function' && callback === undefined) {\n      callback = args;\n      args = [];\n    } else {\n      throw new TypeError('Wrong input type \"' + args.constructor.name + '\" for args');\n    }\n  }\n\n  if (typeof callback !== 'function' && callback !== undefined) {\n    throw new TypeError('Wrong input type \"' + (callback !== null ? callback.constructor.name : 'null') + '\" for callback function');\n  } // Using the raw multi command is only possible with this function\n  // If the command is not yet added to the client, the internal function should be called right away\n  // Otherwise we need to redirect the calls to make sure the internal functions don't get skipped\n  // The internal functions could actually be used for any non hooked function\n  // but this might change from time to time and at the moment there's no good way to distinguish them\n  // from each other, so let's just do it do it this way for the time being\n\n\n  if (command === 'multi' || typeof this[command] !== 'function') {\n    return this.internal_send_command(new Command(command, args, callback));\n  }\n\n  if (typeof callback === 'function') {\n    args = args.concat([callback]); // Prevent manipulating the input array\n  }\n\n  return this[command].apply(this, args);\n};\n\nRedisClient.prototype.end = function (flush) {\n  // Flush queue if wanted\n  if (flush) {\n    this.flush_and_error({\n      message: 'Connection forcefully ended and command aborted.',\n      code: 'NR_CLOSED'\n    });\n  } else if (arguments.length === 0) {\n    this.warn('Using .end() without the flush parameter is deprecated and throws from v.3.0.0 on.\\n' + 'Please check the doku (https://github.com/NodeRedis/node_redis) and explictly use flush.');\n  } // Clear retry_timer\n\n\n  if (this.retry_timer) {\n    clearTimeout(this.retry_timer);\n    this.retry_timer = null;\n  }\n\n  this.stream.removeAllListeners();\n  this.stream.on('error', noop);\n  this.connected = false;\n  this.ready = false;\n  this.closing = true;\n  return this.stream.destroySoon();\n};\n\nRedisClient.prototype.unref = function () {\n  if (this.connected) {\n    debug(\"Unref'ing the socket connection\");\n    this.stream.unref();\n  } else {\n    debug('Not connected yet, will unref later');\n    this.once('connect', function () {\n      this.unref();\n    });\n  }\n};\n\nRedisClient.prototype.duplicate = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  var existing_options = utils.clone(this.options);\n  options = utils.clone(options);\n\n  for (var elem in options) {\n    existing_options[elem] = options[elem];\n  }\n\n  var client = new RedisClient(existing_options);\n  client.selected_db = this.selected_db;\n\n  if (typeof callback === 'function') {\n    var ready_listener = function () {\n      callback(null, client);\n      client.removeAllListeners(error_listener);\n    };\n\n    var error_listener = function (err) {\n      callback(err);\n      client.end(true);\n    };\n\n    client.once('ready', ready_listener);\n    client.once('error', error_listener);\n    return;\n  }\n\n  return client;\n};","map":null,"metadata":{},"sourceType":"script"}