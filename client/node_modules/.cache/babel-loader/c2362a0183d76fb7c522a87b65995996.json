{"ast":null,"code":"'use strict';\n\nvar utils = require('./utils');\n\nvar debug = require('./debug');\n\nvar Multi = require('./multi');\n\nvar Command = require('./command');\n\nvar no_password_is_set = /no password is set/;\nvar loading = /LOADING/;\n\nvar RedisClient = require('../').RedisClient;\n/********************************************************************************************\n Replace built-in redis functions\n\n The callback may be hooked as needed. The same does not apply to the rest of the function.\n State should not be set outside of the callback if not absolutly necessary.\n This is important to make sure it works the same as single command or in a multi context.\n To make sure everything works with the offline queue use the \"call_on_write\" function.\n This is going to be executed while writing to the stream.\n\n TODO: Implement individal command generation as soon as possible to prevent divergent code\n on single and multi calls!\n********************************************************************************************/\n\n\nRedisClient.prototype.multi = RedisClient.prototype.MULTI = function multi(args) {\n  var multi = new Multi(this, args);\n  multi.exec = multi.EXEC = multi.exec_transaction;\n  return multi;\n}; // ATTENTION: This is not a native function but is still handled as a individual command as it behaves just the same as multi\n\n\nRedisClient.prototype.batch = RedisClient.prototype.BATCH = function batch(args) {\n  return new Multi(this, args);\n};\n\nfunction select_callback(self, db, callback) {\n  return function (err, res) {\n    if (err === null) {\n      // Store db in this.select_db to restore it on reconnect\n      self.selected_db = db;\n    }\n\n    utils.callback_or_emit(self, callback, err, res);\n  };\n}\n\nRedisClient.prototype.select = RedisClient.prototype.SELECT = function select(db, callback) {\n  return this.internal_send_command(new Command('select', [db], select_callback(this, db, callback)));\n};\n\nMulti.prototype.select = Multi.prototype.SELECT = function select(db, callback) {\n  this.queue.push(new Command('select', [db], select_callback(this._client, db, callback)));\n  return this;\n};\n\nRedisClient.prototype.monitor = RedisClient.prototype.MONITOR = function monitor(callback) {\n  // Use a individual command, as this is a special case that does not has to be checked for any other command\n  var self = this;\n\n  var call_on_write = function () {\n    // Activating monitor mode has to happen before Redis returned the callback. The monitor result is returned first.\n    // Therefore we expect the command to be properly processed. If this is not the case, it's not an issue either.\n    self.monitoring = true;\n  };\n\n  return this.internal_send_command(new Command('monitor', [], callback, call_on_write));\n}; // Only works with batch, not in a transaction\n\n\nMulti.prototype.monitor = Multi.prototype.MONITOR = function monitor(callback) {\n  // Use a individual command, as this is a special case that does not has to be checked for any other command\n  if (this.exec !== this.exec_transaction) {\n    var self = this;\n\n    var call_on_write = function () {\n      self._client.monitoring = true;\n    };\n\n    this.queue.push(new Command('monitor', [], callback, call_on_write));\n    return this;\n  } // Set multi monitoring to indicate the exec that it should abort\n  // Remove this \"hack\" as soon as Redis might fix this\n\n\n  this.monitoring = true;\n  return this;\n};\n\nfunction quit_callback(self, callback) {\n  return function (err, res) {\n    if (err && err.code === 'NR_CLOSED') {\n      // Pretent the quit command worked properly in this case.\n      // Either the quit landed in the offline queue and was flushed at the reconnect\n      // or the offline queue is deactivated and the command was rejected right away\n      // or the stream is not writable\n      // or while sending the quit, the connection ended / closed\n      err = null;\n      res = 'OK';\n    }\n\n    utils.callback_or_emit(self, callback, err, res);\n\n    if (self.stream.writable) {\n      // If the socket is still alive, kill it. This could happen if quit got a NR_CLOSED error code\n      self.stream.destroy();\n    }\n  };\n}\n\nRedisClient.prototype.QUIT = RedisClient.prototype.quit = function quit(callback) {\n  // TODO: Consider this for v.3\n  // Allow the quit command to be fired as soon as possible to prevent it landing in the offline queue.\n  // this.ready = this.offline_queue.length === 0;\n  var backpressure_indicator = this.internal_send_command(new Command('quit', [], quit_callback(this, callback))); // Calling quit should always end the connection, no matter if there's a connection or not\n\n  this.closing = true;\n  this.ready = false;\n  return backpressure_indicator;\n}; // Only works with batch, not in a transaction\n\n\nMulti.prototype.QUIT = Multi.prototype.quit = function quit(callback) {\n  var self = this._client;\n\n  var call_on_write = function () {\n    // If called in a multi context, we expect redis is available\n    self.closing = true;\n    self.ready = false;\n  };\n\n  this.queue.push(new Command('quit', [], quit_callback(self, callback), call_on_write));\n  return this;\n};\n\nfunction info_callback(self, callback) {\n  return function (err, res) {\n    if (res) {\n      var obj = {};\n      var lines = res.toString().split('\\r\\n');\n      var line, parts, sub_parts;\n\n      for (var i = 0; i < lines.length; i++) {\n        parts = lines[i].split(':');\n\n        if (parts[1]) {\n          if (parts[0].indexOf('db') === 0) {\n            sub_parts = parts[1].split(',');\n            obj[parts[0]] = {};\n\n            while (line = sub_parts.pop()) {\n              line = line.split('=');\n              obj[parts[0]][line[0]] = +line[1];\n            }\n          } else {\n            obj[parts[0]] = parts[1];\n          }\n        }\n      }\n\n      obj.versions = [];\n\n      if (obj.redis_version) {\n        obj.redis_version.split('.').forEach(function (num) {\n          obj.versions.push(+num);\n        });\n      } // Expose info key/vals to users\n\n\n      self.server_info = obj;\n    } else {\n      self.server_info = {};\n    }\n\n    utils.callback_or_emit(self, callback, err, res);\n  };\n} // Store info in this.server_info after each call\n\n\nRedisClient.prototype.info = RedisClient.prototype.INFO = function info(section, callback) {\n  var args = [];\n\n  if (typeof section === 'function') {\n    callback = section;\n  } else if (section !== undefined) {\n    args = Array.isArray(section) ? section : [section];\n  }\n\n  return this.internal_send_command(new Command('info', args, info_callback(this, callback)));\n};\n\nMulti.prototype.info = Multi.prototype.INFO = function info(section, callback) {\n  var args = [];\n\n  if (typeof section === 'function') {\n    callback = section;\n  } else if (section !== undefined) {\n    args = Array.isArray(section) ? section : [section];\n  }\n\n  this.queue.push(new Command('info', args, info_callback(this._client, callback)));\n  return this;\n};\n\nfunction auth_callback(self, pass, callback) {\n  return function (err, res) {\n    if (err) {\n      if (no_password_is_set.test(err.message)) {\n        self.warn('Warning: Redis server does not require a password, but a password was supplied.');\n        err = null;\n        res = 'OK';\n      } else if (loading.test(err.message)) {\n        // If redis is still loading the db, it will not authenticate and everything else will fail\n        debug('Redis still loading, trying to authenticate later');\n        setTimeout(function () {\n          self.auth(pass, callback);\n        }, 100);\n        return;\n      }\n    }\n\n    utils.callback_or_emit(self, callback, err, res);\n  };\n}\n\nRedisClient.prototype.auth = RedisClient.prototype.AUTH = function auth(pass, callback) {\n  debug('Sending auth to ' + this.address + ' id ' + this.connection_id); // Stash auth for connect and reconnect.\n\n  this.auth_pass = pass;\n  var ready = this.ready;\n  this.ready = ready || this.offline_queue.length === 0;\n  var tmp = this.internal_send_command(new Command('auth', [pass], auth_callback(this, pass, callback)));\n  this.ready = ready;\n  return tmp;\n}; // Only works with batch, not in a transaction\n\n\nMulti.prototype.auth = Multi.prototype.AUTH = function auth(pass, callback) {\n  debug('Sending auth to ' + this.address + ' id ' + this.connection_id); // Stash auth for connect and reconnect.\n\n  this.auth_pass = pass;\n  this.queue.push(new Command('auth', [pass], auth_callback(this._client, callback)));\n  return this;\n};\n\nRedisClient.prototype.client = RedisClient.prototype.CLIENT = function client() {\n  var arr,\n      len = arguments.length,\n      callback,\n      i = 0;\n\n  if (Array.isArray(arguments[0])) {\n    arr = arguments[0];\n    callback = arguments[1];\n  } else if (Array.isArray(arguments[1])) {\n    if (len === 3) {\n      callback = arguments[2];\n    }\n\n    len = arguments[1].length;\n    arr = new Array(len + 1);\n    arr[0] = arguments[0];\n\n    for (; i < len; i += 1) {\n      arr[i + 1] = arguments[1][i];\n    }\n  } else {\n    len = arguments.length; // The later should not be the average use case\n\n    if (len !== 0 && (typeof arguments[len - 1] === 'function' || typeof arguments[len - 1] === 'undefined')) {\n      len--;\n      callback = arguments[len];\n    }\n\n    arr = new Array(len);\n\n    for (; i < len; i += 1) {\n      arr[i] = arguments[i];\n    }\n  }\n\n  var self = this;\n  var call_on_write = undefined; // CLIENT REPLY ON|OFF|SKIP\n\n  /* istanbul ignore next: TODO: Remove this as soon as Travis runs Redis 3.2 */\n\n  if (arr.length === 2 && arr[0].toString().toUpperCase() === 'REPLY') {\n    var reply_on_off = arr[1].toString().toUpperCase();\n\n    if (reply_on_off === 'ON' || reply_on_off === 'OFF' || reply_on_off === 'SKIP') {\n      call_on_write = function () {\n        self.reply = reply_on_off;\n      };\n    }\n  }\n\n  return this.internal_send_command(new Command('client', arr, callback, call_on_write));\n};\n\nMulti.prototype.client = Multi.prototype.CLIENT = function client() {\n  var arr,\n      len = arguments.length,\n      callback,\n      i = 0;\n\n  if (Array.isArray(arguments[0])) {\n    arr = arguments[0];\n    callback = arguments[1];\n  } else if (Array.isArray(arguments[1])) {\n    if (len === 3) {\n      callback = arguments[2];\n    }\n\n    len = arguments[1].length;\n    arr = new Array(len + 1);\n    arr[0] = arguments[0];\n\n    for (; i < len; i += 1) {\n      arr[i + 1] = arguments[1][i];\n    }\n  } else {\n    len = arguments.length; // The later should not be the average use case\n\n    if (len !== 0 && (typeof arguments[len - 1] === 'function' || typeof arguments[len - 1] === 'undefined')) {\n      len--;\n      callback = arguments[len];\n    }\n\n    arr = new Array(len);\n\n    for (; i < len; i += 1) {\n      arr[i] = arguments[i];\n    }\n  }\n\n  var self = this._client;\n  var call_on_write = undefined; // CLIENT REPLY ON|OFF|SKIP\n\n  /* istanbul ignore next: TODO: Remove this as soon as Travis runs Redis 3.2 */\n\n  if (arr.length === 2 && arr[0].toString().toUpperCase() === 'REPLY') {\n    var reply_on_off = arr[1].toString().toUpperCase();\n\n    if (reply_on_off === 'ON' || reply_on_off === 'OFF' || reply_on_off === 'SKIP') {\n      call_on_write = function () {\n        self.reply = reply_on_off;\n      };\n    }\n  }\n\n  this.queue.push(new Command('client', arr, callback, call_on_write));\n  return this;\n};\n\nRedisClient.prototype.hmset = RedisClient.prototype.HMSET = function hmset() {\n  var arr,\n      len = arguments.length,\n      callback,\n      i = 0;\n\n  if (Array.isArray(arguments[0])) {\n    arr = arguments[0];\n    callback = arguments[1];\n  } else if (Array.isArray(arguments[1])) {\n    if (len === 3) {\n      callback = arguments[2];\n    }\n\n    len = arguments[1].length;\n    arr = new Array(len + 1);\n    arr[0] = arguments[0];\n\n    for (; i < len; i += 1) {\n      arr[i + 1] = arguments[1][i];\n    }\n  } else if (typeof arguments[1] === 'object' && (arguments.length === 2 || arguments.length === 3 && (typeof arguments[2] === 'function' || typeof arguments[2] === 'undefined'))) {\n    arr = [arguments[0]];\n\n    for (var field in arguments[1]) {\n      arr.push(field, arguments[1][field]);\n    }\n\n    callback = arguments[2];\n  } else {\n    len = arguments.length; // The later should not be the average use case\n\n    if (len !== 0 && (typeof arguments[len - 1] === 'function' || typeof arguments[len - 1] === 'undefined')) {\n      len--;\n      callback = arguments[len];\n    }\n\n    arr = new Array(len);\n\n    for (; i < len; i += 1) {\n      arr[i] = arguments[i];\n    }\n  }\n\n  return this.internal_send_command(new Command('hmset', arr, callback));\n};\n\nMulti.prototype.hmset = Multi.prototype.HMSET = function hmset() {\n  var arr,\n      len = arguments.length,\n      callback,\n      i = 0;\n\n  if (Array.isArray(arguments[0])) {\n    arr = arguments[0];\n    callback = arguments[1];\n  } else if (Array.isArray(arguments[1])) {\n    if (len === 3) {\n      callback = arguments[2];\n    }\n\n    len = arguments[1].length;\n    arr = new Array(len + 1);\n    arr[0] = arguments[0];\n\n    for (; i < len; i += 1) {\n      arr[i + 1] = arguments[1][i];\n    }\n  } else if (typeof arguments[1] === 'object' && (arguments.length === 2 || arguments.length === 3 && (typeof arguments[2] === 'function' || typeof arguments[2] === 'undefined'))) {\n    arr = [arguments[0]];\n\n    for (var field in arguments[1]) {\n      arr.push(field, arguments[1][field]);\n    }\n\n    callback = arguments[2];\n  } else {\n    len = arguments.length; // The later should not be the average use case\n\n    if (len !== 0 && (typeof arguments[len - 1] === 'function' || typeof arguments[len - 1] === 'undefined')) {\n      len--;\n      callback = arguments[len];\n    }\n\n    arr = new Array(len);\n\n    for (; i < len; i += 1) {\n      arr[i] = arguments[i];\n    }\n  }\n\n  this.queue.push(new Command('hmset', arr, callback));\n  return this;\n};\n\nRedisClient.prototype.subscribe = RedisClient.prototype.SUBSCRIBE = function subscribe() {\n  var arr,\n      len = arguments.length,\n      callback,\n      i = 0;\n\n  if (Array.isArray(arguments[0])) {\n    arr = arguments[0].slice(0);\n    callback = arguments[1];\n  } else {\n    len = arguments.length; // The later should not be the average use case\n\n    if (len !== 0 && (typeof arguments[len - 1] === 'function' || typeof arguments[len - 1] === 'undefined')) {\n      len--;\n      callback = arguments[len];\n    }\n\n    arr = new Array(len);\n\n    for (; i < len; i += 1) {\n      arr[i] = arguments[i];\n    }\n  }\n\n  var self = this;\n\n  var call_on_write = function () {\n    self.pub_sub_mode = self.pub_sub_mode || self.command_queue.length + 1;\n  };\n\n  return this.internal_send_command(new Command('subscribe', arr, callback, call_on_write));\n};\n\nMulti.prototype.subscribe = Multi.prototype.SUBSCRIBE = function subscribe() {\n  var arr,\n      len = arguments.length,\n      callback,\n      i = 0;\n\n  if (Array.isArray(arguments[0])) {\n    arr = arguments[0].slice(0);\n    callback = arguments[1];\n  } else {\n    len = arguments.length; // The later should not be the average use case\n\n    if (len !== 0 && (typeof arguments[len - 1] === 'function' || typeof arguments[len - 1] === 'undefined')) {\n      len--;\n      callback = arguments[len];\n    }\n\n    arr = new Array(len);\n\n    for (; i < len; i += 1) {\n      arr[i] = arguments[i];\n    }\n  }\n\n  var self = this._client;\n\n  var call_on_write = function () {\n    self.pub_sub_mode = self.pub_sub_mode || self.command_queue.length + 1;\n  };\n\n  this.queue.push(new Command('subscribe', arr, callback, call_on_write));\n  return this;\n};\n\nRedisClient.prototype.unsubscribe = RedisClient.prototype.UNSUBSCRIBE = function unsubscribe() {\n  var arr,\n      len = arguments.length,\n      callback,\n      i = 0;\n\n  if (Array.isArray(arguments[0])) {\n    arr = arguments[0].slice(0);\n    callback = arguments[1];\n  } else {\n    len = arguments.length; // The later should not be the average use case\n\n    if (len !== 0 && (typeof arguments[len - 1] === 'function' || typeof arguments[len - 1] === 'undefined')) {\n      len--;\n      callback = arguments[len];\n    }\n\n    arr = new Array(len);\n\n    for (; i < len; i += 1) {\n      arr[i] = arguments[i];\n    }\n  }\n\n  var self = this;\n\n  var call_on_write = function () {\n    // Pub sub has to be activated even if not in pub sub mode, as the return value is manipulated in the callback\n    self.pub_sub_mode = self.pub_sub_mode || self.command_queue.length + 1;\n  };\n\n  return this.internal_send_command(new Command('unsubscribe', arr, callback, call_on_write));\n};\n\nMulti.prototype.unsubscribe = Multi.prototype.UNSUBSCRIBE = function unsubscribe() {\n  var arr,\n      len = arguments.length,\n      callback,\n      i = 0;\n\n  if (Array.isArray(arguments[0])) {\n    arr = arguments[0].slice(0);\n    callback = arguments[1];\n  } else {\n    len = arguments.length; // The later should not be the average use case\n\n    if (len !== 0 && (typeof arguments[len - 1] === 'function' || typeof arguments[len - 1] === 'undefined')) {\n      len--;\n      callback = arguments[len];\n    }\n\n    arr = new Array(len);\n\n    for (; i < len; i += 1) {\n      arr[i] = arguments[i];\n    }\n  }\n\n  var self = this._client;\n\n  var call_on_write = function () {\n    // Pub sub has to be activated even if not in pub sub mode, as the return value is manipulated in the callback\n    self.pub_sub_mode = self.pub_sub_mode || self.command_queue.length + 1;\n  };\n\n  this.queue.push(new Command('unsubscribe', arr, callback, call_on_write));\n  return this;\n};\n\nRedisClient.prototype.psubscribe = RedisClient.prototype.PSUBSCRIBE = function psubscribe() {\n  var arr,\n      len = arguments.length,\n      callback,\n      i = 0;\n\n  if (Array.isArray(arguments[0])) {\n    arr = arguments[0].slice(0);\n    callback = arguments[1];\n  } else {\n    len = arguments.length; // The later should not be the average use case\n\n    if (len !== 0 && (typeof arguments[len - 1] === 'function' || typeof arguments[len - 1] === 'undefined')) {\n      len--;\n      callback = arguments[len];\n    }\n\n    arr = new Array(len);\n\n    for (; i < len; i += 1) {\n      arr[i] = arguments[i];\n    }\n  }\n\n  var self = this;\n\n  var call_on_write = function () {\n    self.pub_sub_mode = self.pub_sub_mode || self.command_queue.length + 1;\n  };\n\n  return this.internal_send_command(new Command('psubscribe', arr, callback, call_on_write));\n};\n\nMulti.prototype.psubscribe = Multi.prototype.PSUBSCRIBE = function psubscribe() {\n  var arr,\n      len = arguments.length,\n      callback,\n      i = 0;\n\n  if (Array.isArray(arguments[0])) {\n    arr = arguments[0].slice(0);\n    callback = arguments[1];\n  } else {\n    len = arguments.length; // The later should not be the average use case\n\n    if (len !== 0 && (typeof arguments[len - 1] === 'function' || typeof arguments[len - 1] === 'undefined')) {\n      len--;\n      callback = arguments[len];\n    }\n\n    arr = new Array(len);\n\n    for (; i < len; i += 1) {\n      arr[i] = arguments[i];\n    }\n  }\n\n  var self = this._client;\n\n  var call_on_write = function () {\n    self.pub_sub_mode = self.pub_sub_mode || self.command_queue.length + 1;\n  };\n\n  this.queue.push(new Command('psubscribe', arr, callback, call_on_write));\n  return this;\n};\n\nRedisClient.prototype.punsubscribe = RedisClient.prototype.PUNSUBSCRIBE = function punsubscribe() {\n  var arr,\n      len = arguments.length,\n      callback,\n      i = 0;\n\n  if (Array.isArray(arguments[0])) {\n    arr = arguments[0].slice(0);\n    callback = arguments[1];\n  } else {\n    len = arguments.length; // The later should not be the average use case\n\n    if (len !== 0 && (typeof arguments[len - 1] === 'function' || typeof arguments[len - 1] === 'undefined')) {\n      len--;\n      callback = arguments[len];\n    }\n\n    arr = new Array(len);\n\n    for (; i < len; i += 1) {\n      arr[i] = arguments[i];\n    }\n  }\n\n  var self = this;\n\n  var call_on_write = function () {\n    // Pub sub has to be activated even if not in pub sub mode, as the return value is manipulated in the callback\n    self.pub_sub_mode = self.pub_sub_mode || self.command_queue.length + 1;\n  };\n\n  return this.internal_send_command(new Command('punsubscribe', arr, callback, call_on_write));\n};\n\nMulti.prototype.punsubscribe = Multi.prototype.PUNSUBSCRIBE = function punsubscribe() {\n  var arr,\n      len = arguments.length,\n      callback,\n      i = 0;\n\n  if (Array.isArray(arguments[0])) {\n    arr = arguments[0].slice(0);\n    callback = arguments[1];\n  } else {\n    len = arguments.length; // The later should not be the average use case\n\n    if (len !== 0 && (typeof arguments[len - 1] === 'function' || typeof arguments[len - 1] === 'undefined')) {\n      len--;\n      callback = arguments[len];\n    }\n\n    arr = new Array(len);\n\n    for (; i < len; i += 1) {\n      arr[i] = arguments[i];\n    }\n  }\n\n  var self = this._client;\n\n  var call_on_write = function () {\n    // Pub sub has to be activated even if not in pub sub mode, as the return value is manipulated in the callback\n    self.pub_sub_mode = self.pub_sub_mode || self.command_queue.length + 1;\n  };\n\n  this.queue.push(new Command('punsubscribe', arr, callback, call_on_write));\n  return this;\n};","map":null,"metadata":{},"sourceType":"script"}