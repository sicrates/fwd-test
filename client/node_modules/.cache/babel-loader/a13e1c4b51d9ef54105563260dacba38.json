{"ast":null,"code":"'use strict';\n\nvar StringDecoder = require('string_decoder').StringDecoder;\n\nvar decoder = new StringDecoder();\n\nvar ReplyError = require('./replyError');\n\nvar ParserError = require('./parserError');\n\nvar bufferPool = bufferAlloc(32 * 1024);\nvar bufferOffset = 0;\nvar interval = null;\nvar counter = 0;\nvar notDecreased = 0;\nvar isModern = typeof Buffer.allocUnsafe === 'function';\n/**\n * For backwards compatibility\n * @param len\n * @returns {Buffer}\n */\n\nfunction bufferAlloc(len) {\n  return isModern ? Buffer.allocUnsafe(len) : new Buffer(len);\n}\n/**\n * Used for lengths and numbers only, faster perf on arrays / bulks\n * @param parser\n * @returns {*}\n */\n\n\nfunction parseSimpleNumbers(parser) {\n  var offset = parser.offset;\n  var length = parser.buffer.length - 1;\n  var number = 0;\n  var sign = 1;\n\n  if (parser.buffer[offset] === 45) {\n    sign = -1;\n    offset++;\n  }\n\n  while (offset < length) {\n    var c1 = parser.buffer[offset++];\n\n    if (c1 === 13) {\n      // \\r\\n\n      parser.offset = offset + 1;\n      return sign * number;\n    }\n\n    number = number * 10 + (c1 - 48);\n  }\n}\n/**\n * Used for integer numbers in case of the returnNumbers option\n *\n * The maximimum possible integer to use is: Math.floor(Number.MAX_SAFE_INTEGER / 10)\n * Staying in a SMI Math.floor((Math.pow(2, 32) / 10) - 1) is even more efficient though\n *\n * @param parser\n * @returns {*}\n */\n\n\nfunction parseStringNumbers(parser) {\n  var offset = parser.offset;\n  var length = parser.buffer.length - 1;\n  var number = 0;\n  var res = '';\n\n  if (parser.buffer[offset] === 45) {\n    res += '-';\n    offset++;\n  }\n\n  while (offset < length) {\n    var c1 = parser.buffer[offset++];\n\n    if (c1 === 13) {\n      // \\r\\n\n      parser.offset = offset + 1;\n\n      if (number !== 0) {\n        res += number;\n      }\n\n      return res;\n    } else if (number > 429496728) {\n      res += number * 10 + (c1 - 48);\n      number = 0;\n    } else if (c1 === 48 && number === 0) {\n      res += 0;\n    } else {\n      number = number * 10 + (c1 - 48);\n    }\n  }\n}\n/**\n * Returns a string or buffer of the provided offset start and\n * end ranges. Checks `optionReturnBuffers`.\n *\n * If returnBuffers is active, all return values are returned as buffers besides numbers and errors\n *\n * @param parser\n * @param start\n * @param end\n * @returns {*}\n */\n\n\nfunction convertBufferRange(parser, start, end) {\n  parser.offset = end + 2;\n\n  if (parser.optionReturnBuffers === true) {\n    return parser.buffer.slice(start, end);\n  }\n\n  return parser.buffer.toString('utf-8', start, end);\n}\n/**\n * Parse a '+' redis simple string response but forward the offsets\n * onto convertBufferRange to generate a string.\n * @param parser\n * @returns {*}\n */\n\n\nfunction parseSimpleString(parser) {\n  var start = parser.offset;\n  var offset = start;\n  var buffer = parser.buffer;\n  var length = buffer.length - 1;\n\n  while (offset < length) {\n    if (buffer[offset++] === 13) {\n      // \\r\\n\n      return convertBufferRange(parser, start, offset - 1);\n    }\n  }\n}\n/**\n * Returns the string length via parseSimpleNumbers\n * @param parser\n * @returns {*}\n */\n\n\nfunction parseLength(parser) {\n  var string = parseSimpleNumbers(parser);\n\n  if (string !== undefined) {\n    return string;\n  }\n}\n/**\n * Parse a ':' redis integer response\n *\n * If stringNumbers is activated the parser always returns numbers as string\n * This is important for big numbers (number > Math.pow(2, 53)) as js numbers\n * are 64bit floating point numbers with reduced precision\n *\n * @param parser\n * @returns {*}\n */\n\n\nfunction parseInteger(parser) {\n  if (parser.optionStringNumbers) {\n    return parseStringNumbers(parser);\n  }\n\n  return parseSimpleNumbers(parser);\n}\n/**\n * Parse a '$' redis bulk string response\n * @param parser\n * @returns {*}\n */\n\n\nfunction parseBulkString(parser) {\n  var length = parseLength(parser);\n\n  if (length === undefined) {\n    return;\n  }\n\n  if (length === -1) {\n    return null;\n  }\n\n  var offsetEnd = parser.offset + length;\n\n  if (offsetEnd + 2 > parser.buffer.length) {\n    parser.bigStrSize = offsetEnd + 2;\n    parser.bigOffset = parser.offset;\n    parser.totalChunkSize = parser.buffer.length;\n    parser.bufferCache.push(parser.buffer);\n    return;\n  }\n\n  return convertBufferRange(parser, parser.offset, offsetEnd);\n}\n/**\n * Parse a '-' redis error response\n * @param parser\n * @returns {Error}\n */\n\n\nfunction parseError(parser) {\n  var string = parseSimpleString(parser);\n\n  if (string !== undefined) {\n    if (parser.optionReturnBuffers === true) {\n      string = string.toString();\n    }\n\n    return new ReplyError(string);\n  }\n}\n/**\n * Parsing error handler, resets parser buffer\n * @param parser\n * @param error\n */\n\n\nfunction handleError(parser, error) {\n  parser.buffer = null;\n  parser.returnFatalError(error);\n}\n/**\n * Parse a '*' redis array response\n * @param parser\n * @returns {*}\n */\n\n\nfunction parseArray(parser) {\n  var length = parseLength(parser);\n\n  if (length === undefined) {\n    return;\n  }\n\n  if (length === -1) {\n    return null;\n  }\n\n  var responses = new Array(length);\n  return parseArrayElements(parser, responses, 0);\n}\n/**\n * Push a partly parsed array to the stack\n *\n * @param parser\n * @param elem\n * @param i\n * @returns {undefined}\n */\n\n\nfunction pushArrayCache(parser, elem, pos) {\n  parser.arrayCache.push(elem);\n  parser.arrayPos.push(pos);\n}\n/**\n * Parse chunked redis array response\n * @param parser\n * @returns {*}\n */\n\n\nfunction parseArrayChunks(parser) {\n  var tmp = parser.arrayCache.pop();\n  var pos = parser.arrayPos.pop();\n\n  if (parser.arrayCache.length) {\n    var res = parseArrayChunks(parser);\n\n    if (!res) {\n      pushArrayCache(parser, tmp, pos);\n      return;\n    }\n\n    tmp[pos++] = res;\n  }\n\n  return parseArrayElements(parser, tmp, pos);\n}\n/**\n * Parse redis array response elements\n * @param parser\n * @param responses\n * @param i\n * @returns {*}\n */\n\n\nfunction parseArrayElements(parser, responses, i) {\n  var bufferLength = parser.buffer.length;\n\n  while (i < responses.length) {\n    var offset = parser.offset;\n\n    if (parser.offset >= bufferLength) {\n      pushArrayCache(parser, responses, i);\n      return;\n    }\n\n    var response = parseType(parser, parser.buffer[parser.offset++]);\n\n    if (response === undefined) {\n      if (!parser.arrayCache.length) {\n        parser.offset = offset;\n      }\n\n      pushArrayCache(parser, responses, i);\n      return;\n    }\n\n    responses[i] = response;\n    i++;\n  }\n\n  return responses;\n}\n/**\n * Called the appropriate parser for the specified type.\n * @param parser\n * @param type\n * @returns {*}\n */\n\n\nfunction parseType(parser, type) {\n  switch (type) {\n    case 36:\n      // $\n      return parseBulkString(parser);\n\n    case 58:\n      // :\n      return parseInteger(parser);\n\n    case 43:\n      // +\n      return parseSimpleString(parser);\n\n    case 42:\n      // *\n      return parseArray(parser);\n\n    case 45:\n      // -\n      return parseError(parser);\n\n    default:\n      return handleError(parser, new ParserError('Protocol error, got ' + JSON.stringify(String.fromCharCode(type)) + ' as reply type byte', JSON.stringify(parser.buffer), parser.offset));\n  }\n} // All allowed options including their typeof value\n\n\nvar optionTypes = {\n  returnError: 'function',\n  returnFatalError: 'function',\n  returnReply: 'function',\n  returnBuffers: 'boolean',\n  stringNumbers: 'boolean',\n  name: 'string'\n  /**\n   * Javascript Redis Parser\n   * @param options\n   * @constructor\n   */\n\n};\n\nfunction JavascriptRedisParser(options) {\n  if (!(this instanceof JavascriptRedisParser)) {\n    return new JavascriptRedisParser(options);\n  }\n\n  if (!options || !options.returnError || !options.returnReply) {\n    throw new TypeError('Please provide all return functions while initiating the parser');\n  }\n\n  for (var key in options) {\n    // eslint-disable-next-line valid-typeof\n    if (optionTypes.hasOwnProperty(key) && typeof options[key] !== optionTypes[key]) {\n      throw new TypeError('The options argument contains the property \"' + key + '\" that is either unknown or of a wrong type');\n    }\n  }\n\n  if (options.name === 'hiredis') {\n    /* istanbul ignore next: hiredis is only supported for legacy usage */\n    try {\n      var Hiredis = require('./hiredis');\n\n      console.error(new TypeError('Using hiredis is discouraged. Please use the faster JS parser by removing the name option.').stack.replace('Error', 'Warning'));\n      return new Hiredis(options);\n    } catch (e) {\n      console.error(new TypeError('Hiredis is not installed. Please remove the `name` option. The (faster) JS parser is used instead.').stack.replace('Error', 'Warning'));\n    }\n  }\n\n  this.optionReturnBuffers = !!options.returnBuffers;\n  this.optionStringNumbers = !!options.stringNumbers;\n  this.returnError = options.returnError;\n  this.returnFatalError = options.returnFatalError || options.returnError;\n  this.returnReply = options.returnReply;\n  this.name = 'javascript';\n  this.reset();\n}\n/**\n * Reset the parser values to the initial state\n *\n * @returns {undefined}\n */\n\n\nJavascriptRedisParser.prototype.reset = function () {\n  this.offset = 0;\n  this.buffer = null;\n  this.bigStrSize = 0;\n  this.bigOffset = 0;\n  this.totalChunkSize = 0;\n  this.bufferCache = [];\n  this.arrayCache = [];\n  this.arrayPos = [];\n};\n/**\n * Set the returnBuffers option\n *\n * @param returnBuffers\n * @returns {undefined}\n */\n\n\nJavascriptRedisParser.prototype.setReturnBuffers = function (returnBuffers) {\n  if (typeof returnBuffers !== 'boolean') {\n    throw new TypeError('The returnBuffers argument has to be a boolean');\n  }\n\n  this.optionReturnBuffers = returnBuffers;\n};\n/**\n * Set the stringNumbers option\n *\n * @param stringNumbers\n * @returns {undefined}\n */\n\n\nJavascriptRedisParser.prototype.setStringNumbers = function (stringNumbers) {\n  if (typeof stringNumbers !== 'boolean') {\n    throw new TypeError('The stringNumbers argument has to be a boolean');\n  }\n\n  this.optionStringNumbers = stringNumbers;\n};\n/**\n * Decrease the bufferPool size over time\n * @returns {undefined}\n */\n\n\nfunction decreaseBufferPool() {\n  if (bufferPool.length > 50 * 1024) {\n    // Balance between increasing and decreasing the bufferPool\n    if (counter === 1 || notDecreased > counter * 2) {\n      // Decrease the bufferPool by 10% by removing the first 10% of the current pool\n      var sliceLength = Math.floor(bufferPool.length / 10);\n\n      if (bufferOffset <= sliceLength) {\n        bufferOffset = 0;\n      } else {\n        bufferOffset -= sliceLength;\n      }\n\n      bufferPool = bufferPool.slice(sliceLength, bufferPool.length);\n    } else {\n      notDecreased++;\n      counter--;\n    }\n  } else {\n    clearInterval(interval);\n    counter = 0;\n    notDecreased = 0;\n    interval = null;\n  }\n}\n/**\n * Check if the requested size fits in the current bufferPool.\n * If it does not, reset and increase the bufferPool accordingly.\n *\n * @param length\n * @returns {undefined}\n */\n\n\nfunction resizeBuffer(length) {\n  if (bufferPool.length < length + bufferOffset) {\n    var multiplier = length > 1024 * 1024 * 75 ? 2 : 3;\n\n    if (bufferOffset > 1024 * 1024 * 111) {\n      bufferOffset = 1024 * 1024 * 50;\n    }\n\n    bufferPool = bufferAlloc(length * multiplier + bufferOffset);\n    bufferOffset = 0;\n    counter++;\n\n    if (interval === null) {\n      interval = setInterval(decreaseBufferPool, 50);\n    }\n  }\n}\n/**\n * Concat a bulk string containing multiple chunks\n *\n * Notes:\n * 1) The first chunk might contain the whole bulk string including the \\r\n * 2) We are only safe to fully add up elements that are neither the first nor any of the last two elements\n *\n * @param parser\n * @returns {String}\n */\n\n\nfunction concatBulkString(parser) {\n  var list = parser.bufferCache;\n  var chunks = list.length;\n  var offset = parser.bigStrSize - parser.totalChunkSize;\n  parser.offset = offset;\n\n  if (offset <= 2) {\n    if (chunks === 2) {\n      return list[0].toString('utf8', parser.bigOffset, list[0].length + offset - 2);\n    }\n\n    chunks--;\n    offset = list[list.length - 2].length + offset;\n  }\n\n  var res = decoder.write(list[0].slice(parser.bigOffset));\n\n  for (var i = 1; i < chunks - 1; i++) {\n    res += decoder.write(list[i]);\n  }\n\n  res += decoder.end(list[i].slice(0, offset - 2));\n  return res;\n}\n/**\n * Concat the collected chunks from parser.bufferCache.\n *\n * Increases the bufferPool size beforehand if necessary.\n *\n * @param parser\n * @returns {Buffer}\n */\n\n\nfunction concatBulkBuffer(parser) {\n  var list = parser.bufferCache;\n  var chunks = list.length;\n  var length = parser.bigStrSize - parser.bigOffset - 2;\n  var offset = parser.bigStrSize - parser.totalChunkSize;\n  parser.offset = offset;\n\n  if (offset <= 2) {\n    if (chunks === 2) {\n      return list[0].slice(parser.bigOffset, list[0].length + offset - 2);\n    }\n\n    chunks--;\n    offset = list[list.length - 2].length + offset;\n  }\n\n  resizeBuffer(length);\n  var start = bufferOffset;\n  list[0].copy(bufferPool, start, parser.bigOffset, list[0].length);\n  bufferOffset += list[0].length - parser.bigOffset;\n\n  for (var i = 1; i < chunks - 1; i++) {\n    list[i].copy(bufferPool, bufferOffset);\n    bufferOffset += list[i].length;\n  }\n\n  list[i].copy(bufferPool, bufferOffset, 0, offset - 2);\n  bufferOffset += offset - 2;\n  return bufferPool.slice(start, bufferOffset);\n}\n/**\n * Parse the redis buffer\n * @param buffer\n * @returns {undefined}\n */\n\n\nJavascriptRedisParser.prototype.execute = function execute(buffer) {\n  if (this.buffer === null) {\n    this.buffer = buffer;\n    this.offset = 0;\n  } else if (this.bigStrSize === 0) {\n    var oldLength = this.buffer.length;\n    var remainingLength = oldLength - this.offset;\n    var newBuffer = bufferAlloc(remainingLength + buffer.length);\n    this.buffer.copy(newBuffer, 0, this.offset, oldLength);\n    buffer.copy(newBuffer, remainingLength, 0, buffer.length);\n    this.buffer = newBuffer;\n    this.offset = 0;\n\n    if (this.arrayCache.length) {\n      var arr = parseArrayChunks(this);\n\n      if (!arr) {\n        return;\n      }\n\n      this.returnReply(arr);\n    }\n  } else if (this.totalChunkSize + buffer.length >= this.bigStrSize) {\n    this.bufferCache.push(buffer);\n    var tmp = this.optionReturnBuffers ? concatBulkBuffer(this) : concatBulkString(this);\n    this.bigStrSize = 0;\n    this.bufferCache = [];\n    this.buffer = buffer;\n\n    if (this.arrayCache.length) {\n      this.arrayCache[0][this.arrayPos[0]++] = tmp;\n      tmp = parseArrayChunks(this);\n\n      if (!tmp) {\n        return;\n      }\n    }\n\n    this.returnReply(tmp);\n  } else {\n    this.bufferCache.push(buffer);\n    this.totalChunkSize += buffer.length;\n    return;\n  }\n\n  while (this.offset < this.buffer.length) {\n    var offset = this.offset;\n    var type = this.buffer[this.offset++];\n    var response = parseType(this, type);\n\n    if (response === undefined) {\n      if (!this.arrayCache.length) {\n        this.offset = offset;\n      }\n\n      return;\n    }\n\n    if (type === 45) {\n      this.returnError(response);\n    } else {\n      this.returnReply(response);\n    }\n  }\n\n  this.buffer = null;\n};\n\nmodule.exports = JavascriptRedisParser;","map":null,"metadata":{},"sourceType":"script"}