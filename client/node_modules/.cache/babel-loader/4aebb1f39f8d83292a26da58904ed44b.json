{"ast":null,"code":"'use strict'; // hgetall converts its replies to an Object. If the reply is empty, null is returned.\n// These function are only called with internal data and have therefore always the same instanceof X\n\nfunction replyToObject(reply) {\n  // The reply might be a string or a buffer if this is called in a transaction (multi)\n  if (reply.length === 0 || !(reply instanceof Array)) {\n    return null;\n  }\n\n  var obj = {};\n\n  for (var i = 0; i < reply.length; i += 2) {\n    obj[reply[i].toString('binary')] = reply[i + 1];\n  }\n\n  return obj;\n}\n\nfunction replyToStrings(reply) {\n  if (reply instanceof Buffer) {\n    return reply.toString();\n  }\n\n  if (reply instanceof Array) {\n    var res = new Array(reply.length);\n\n    for (var i = 0; i < reply.length; i++) {\n      // Recusivly call the function as slowlog returns deep nested replies\n      res[i] = replyToStrings(reply[i]);\n    }\n\n    return res;\n  }\n\n  return reply;\n}\n\nfunction print(err, reply) {\n  if (err) {\n    // A error always begins with Error:\n    console.log(err.toString());\n  } else {\n    console.log('Reply: ' + reply);\n  }\n}\n\nvar camelCase; // Deep clone arbitrary objects with arrays. Can't handle cyclic structures (results in a range error)\n// Any attribute with a non primitive value besides object and array will be passed by reference (e.g. Buffers, Maps, Functions)\n// All capital letters are going to be replaced with a lower case letter and a underscore infront of it\n\nfunction clone(obj) {\n  var copy;\n\n  if (Array.isArray(obj)) {\n    copy = new Array(obj.length);\n\n    for (var i = 0; i < obj.length; i++) {\n      copy[i] = clone(obj[i]);\n    }\n\n    return copy;\n  }\n\n  if (Object.prototype.toString.call(obj) === '[object Object]') {\n    copy = {};\n    var elems = Object.keys(obj);\n    var elem;\n\n    while (elem = elems.pop()) {\n      if (elem === 'tls') {\n        // special handle tls\n        copy[elem] = obj[elem];\n        continue;\n      } // Accept camelCase options and convert them to snake_case\n\n\n      var snake_case = elem.replace(/[A-Z][^A-Z]/g, '_$&').toLowerCase(); // If camelCase is detected, pass it to the client, so all variables are going to be camelCased\n      // There are no deep nested options objects yet, but let's handle this future proof\n\n      if (snake_case !== elem.toLowerCase()) {\n        camelCase = true;\n      }\n\n      copy[snake_case] = clone(obj[elem]);\n    }\n\n    return copy;\n  }\n\n  return obj;\n}\n\nfunction convenienceClone(obj) {\n  camelCase = false;\n  obj = clone(obj) || {};\n\n  if (camelCase) {\n    obj.camel_case = true;\n  }\n\n  return obj;\n}\n\nfunction callbackOrEmit(self, callback, err, res) {\n  if (callback) {\n    callback(err, res);\n  } else if (err) {\n    self.emit('error', err);\n  }\n}\n\nfunction replyInOrder(self, callback, err, res, queue) {\n  // If the queue is explicitly passed, use that, otherwise fall back to the offline queue first,\n  // as there might be commands in both queues at the same time\n  var command_obj;\n  /* istanbul ignore if: TODO: Remove this as soon as we test Redis 3.2 on travis */\n\n  if (queue) {\n    command_obj = queue.peekBack();\n  } else {\n    command_obj = self.offline_queue.peekBack() || self.command_queue.peekBack();\n  }\n\n  if (!command_obj) {\n    process.nextTick(function () {\n      callbackOrEmit(self, callback, err, res);\n    });\n  } else {\n    var tmp = command_obj.callback;\n    command_obj.callback = tmp ? function (e, r) {\n      tmp(e, r);\n      callbackOrEmit(self, callback, err, res);\n    } : function (e, r) {\n      if (e) {\n        self.emit('error', e);\n      }\n\n      callbackOrEmit(self, callback, err, res);\n    };\n  }\n}\n\nmodule.exports = {\n  reply_to_strings: replyToStrings,\n  reply_to_object: replyToObject,\n  print: print,\n  err_code: /^([A-Z]+)\\s+(.+)$/,\n  monitor_regex: /^[0-9]{10,11}\\.[0-9]+ \\[[0-9]+ .+\\]( \".+?\")+$/,\n  clone: convenienceClone,\n  callback_or_emit: callbackOrEmit,\n  reply_in_order: replyInOrder\n};","map":null,"metadata":{},"sourceType":"script"}