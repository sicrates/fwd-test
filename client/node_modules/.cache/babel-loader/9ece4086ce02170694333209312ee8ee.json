{"ast":null,"code":"'use strict';\n\nvar Queue = require('double-ended-queue');\n\nvar utils = require('./utils');\n\nvar Command = require('./command');\n\nfunction Multi(client, args) {\n  this._client = client;\n  this.queue = new Queue();\n  var command, tmp_args;\n\n  if (args) {\n    // Either undefined or an array. Fail hard if it's not an array\n    for (var i = 0; i < args.length; i++) {\n      command = args[i][0];\n      tmp_args = args[i].slice(1);\n\n      if (Array.isArray(command)) {\n        this[command[0]].apply(this, command.slice(1).concat(tmp_args));\n      } else {\n        this[command].apply(this, tmp_args);\n      }\n    }\n  }\n}\n\nfunction pipeline_transaction_command(self, command_obj, index) {\n  // Queueing is done first, then the commands are executed\n  var tmp = command_obj.callback;\n\n  command_obj.callback = function (err, reply) {\n    // Ignore the multi command. This is applied by node_redis and the user does not benefit by it\n    if (err && index !== -1) {\n      if (tmp) {\n        tmp(err);\n      }\n\n      err.position = index;\n      self.errors.push(err);\n    } // Keep track of who wants buffer responses:\n    // By the time the callback is called the command_obj got the buffer_args attribute attached\n\n\n    self.wants_buffers[index] = command_obj.buffer_args;\n    command_obj.callback = tmp;\n  };\n\n  self._client.internal_send_command(command_obj);\n}\n\nMulti.prototype.exec_atomic = Multi.prototype.EXEC_ATOMIC = Multi.prototype.execAtomic = function exec_atomic(callback) {\n  if (this.queue.length < 2) {\n    return this.exec_batch(callback);\n  }\n\n  return this.exec(callback);\n};\n\nfunction multi_callback(self, err, replies) {\n  var i = 0,\n      command_obj;\n\n  if (err) {\n    err.errors = self.errors;\n\n    if (self.callback) {\n      self.callback(err); // Exclude connection errors so that those errors won't be emitted twice\n    } else if (err.code !== 'CONNECTION_BROKEN') {\n      self._client.emit('error', err);\n    }\n\n    return;\n  }\n\n  if (replies) {\n    while (command_obj = self.queue.shift()) {\n      if (replies[i] instanceof Error) {\n        var match = replies[i].message.match(utils.err_code); // LUA script could return user errors that don't behave like all other errors!\n\n        if (match) {\n          replies[i].code = match[1];\n        }\n\n        replies[i].command = command_obj.command.toUpperCase();\n\n        if (typeof command_obj.callback === 'function') {\n          command_obj.callback(replies[i]);\n        }\n      } else {\n        // If we asked for strings, even in detect_buffers mode, then return strings:\n        replies[i] = self._client.handle_reply(replies[i], command_obj.command, self.wants_buffers[i]);\n\n        if (typeof command_obj.callback === 'function') {\n          command_obj.callback(null, replies[i]);\n        }\n      }\n\n      i++;\n    }\n  }\n\n  if (self.callback) {\n    self.callback(null, replies);\n  }\n}\n\nMulti.prototype.exec_transaction = function exec_transaction(callback) {\n  if (this.monitoring || this._client.monitoring) {\n    var err = new RangeError('Using transaction with a client that is in monitor mode does not work due to faulty return values of Redis.');\n    err.command = 'EXEC';\n    err.code = 'EXECABORT';\n    return utils.reply_in_order(this._client, callback, err);\n  }\n\n  var self = this;\n  var len = self.queue.length;\n  self.errors = [];\n  self.callback = callback;\n\n  self._client.cork();\n\n  self.wants_buffers = new Array(len);\n  pipeline_transaction_command(self, new Command('multi', []), -1); // Drain queue, callback will catch 'QUEUED' or error\n\n  for (var index = 0; index < len; index++) {\n    // The commands may not be shifted off, since they are needed in the result handler\n    pipeline_transaction_command(self, self.queue.get(index), index);\n  }\n\n  self._client.internal_send_command(new Command('exec', [], function (err, replies) {\n    multi_callback(self, err, replies);\n  }));\n\n  self._client.uncork();\n\n  return !self._client.should_buffer;\n};\n\nfunction batch_callback(self, cb, i) {\n  return function batch_callback(err, res) {\n    if (err) {\n      self.results[i] = err; // Add the position to the error\n\n      self.results[i].position = i;\n    } else {\n      self.results[i] = res;\n    }\n\n    cb(err, res);\n  };\n}\n\nMulti.prototype.exec = Multi.prototype.EXEC = Multi.prototype.exec_batch = function exec_batch(callback) {\n  var self = this;\n  var len = self.queue.length;\n  var index = 0;\n  var command_obj;\n\n  if (len === 0) {\n    utils.reply_in_order(self._client, callback, null, []);\n    return !self._client.should_buffer;\n  }\n\n  self._client.cork();\n\n  if (!callback) {\n    while (command_obj = self.queue.shift()) {\n      self._client.internal_send_command(command_obj);\n    }\n\n    self._client.uncork();\n\n    return !self._client.should_buffer;\n  }\n\n  var callback_without_own_cb = function (err, res) {\n    if (err) {\n      self.results.push(err); // Add the position to the error\n\n      var i = self.results.length - 1;\n      self.results[i].position = i;\n    } else {\n      self.results.push(res);\n    } // Do not emit an error here. Otherwise each error would result in one emit.\n    // The errors will be returned in the result anyway\n\n  };\n\n  var last_callback = function (cb) {\n    return function (err, res) {\n      cb(err, res);\n      callback(null, self.results);\n    };\n  };\n\n  self.results = [];\n\n  while (command_obj = self.queue.shift()) {\n    if (typeof command_obj.callback === 'function') {\n      command_obj.callback = batch_callback(self, command_obj.callback, index);\n    } else {\n      command_obj.callback = callback_without_own_cb;\n    }\n\n    if (typeof callback === 'function' && index === len - 1) {\n      command_obj.callback = last_callback(command_obj.callback);\n    }\n\n    this._client.internal_send_command(command_obj);\n\n    index++;\n  }\n\n  self._client.uncork();\n\n  return !self._client.should_buffer;\n};\n\nmodule.exports = Multi;","map":null,"metadata":{},"sourceType":"script"}