{"ast":null,"code":"'use strict';\n\nvar net = require('net');\n\nvar tls = require('tls');\n\nvar util = require('util');\n\nvar utils = require('./lib/utils');\n\nvar Command = require('./lib/command');\n\nvar Queue = require('double-ended-queue');\n\nvar errorClasses = require('./lib/customErrors');\n\nvar EventEmitter = require('events');\n\nvar Parser = require('redis-parser');\n\nvar commands = require('redis-commands');\n\nvar debug = require('./lib/debug');\n\nvar unifyOptions = require('./lib/createClient');\n\nvar SUBSCRIBE_COMMANDS = {\n  subscribe: true,\n  unsubscribe: true,\n  psubscribe: true,\n  punsubscribe: true\n}; // Newer Node.js versions > 0.10 return the EventEmitter right away and using .EventEmitter was deprecated\n\nif (typeof EventEmitter !== 'function') {\n  EventEmitter = EventEmitter.EventEmitter;\n}\n\nfunction noop() {}\n\nfunction handle_detect_buffers_reply(reply, command, buffer_args) {\n  if (buffer_args === false || this.message_buffers) {\n    // If detect_buffers option was specified, then the reply from the parser will be a buffer.\n    // If this command did not use Buffer arguments, then convert the reply to Strings here.\n    reply = utils.reply_to_strings(reply);\n  }\n\n  if (command === 'hgetall') {\n    reply = utils.reply_to_object(reply);\n  }\n\n  return reply;\n}\n\nexports.debug_mode = /\\bredis\\b/i.test(process.env.NODE_DEBUG); // Attention: The second parameter might be removed at will and is not officially supported.\n// Do not rely on this\n\nfunction RedisClient(options, stream) {\n  // Copy the options so they are not mutated\n  options = utils.clone(options);\n  EventEmitter.call(this);\n  var cnx_options = {};\n  var self = this;\n  /* istanbul ignore next: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n\n  for (var tls_option in options.tls) {\n    cnx_options[tls_option] = options.tls[tls_option]; // Copy the tls options into the general options to make sure the address is set right\n\n    if (tls_option === 'port' || tls_option === 'host' || tls_option === 'path' || tls_option === 'family') {\n      options[tls_option] = options.tls[tls_option];\n    }\n  }\n\n  if (stream) {\n    // The stream from the outside is used so no connection from this side is triggered but from the server this client should talk to\n    // Reconnect etc won't work with this. This requires monkey patching to work, so it is not officially supported\n    options.stream = stream;\n    this.address = '\"Private stream\"';\n  } else if (options.path) {\n    cnx_options.path = options.path;\n    this.address = options.path;\n  } else {\n    cnx_options.port = +options.port || 6379;\n    cnx_options.host = options.host || '127.0.0.1';\n    cnx_options.family = !options.family && net.isIP(cnx_options.host) || (options.family === 'IPv6' ? 6 : 4);\n    this.address = cnx_options.host + ':' + cnx_options.port;\n  } // Warn on misusing deprecated functions\n\n\n  if (typeof options.retry_strategy === 'function') {\n    if ('max_attempts' in options) {\n      self.warn('WARNING: You activated the retry_strategy and max_attempts at the same time. This is not possible and max_attempts will be ignored.'); // Do not print deprecation warnings twice\n\n      delete options.max_attempts;\n    }\n\n    if ('retry_max_delay' in options) {\n      self.warn('WARNING: You activated the retry_strategy and retry_max_delay at the same time. This is not possible and retry_max_delay will be ignored.'); // Do not print deprecation warnings twice\n\n      delete options.retry_max_delay;\n    }\n  }\n\n  this.connection_options = cnx_options;\n  this.connection_id = RedisClient.connection_id++;\n  this.connected = false;\n  this.ready = false;\n\n  if (options.socket_nodelay === undefined) {\n    options.socket_nodelay = true;\n  } else if (!options.socket_nodelay) {\n    // Only warn users with this set to false\n    self.warn('socket_nodelay is deprecated and will be removed in v.3.0.0.\\n' + 'Setting socket_nodelay to false likely results in a reduced throughput. Please use .batch for pipelining instead.\\n' + 'If you are sure you rely on the NAGLE-algorithm you can activate it by calling client.stream.setNoDelay(false) instead.');\n  }\n\n  if (options.socket_keepalive === undefined) {\n    options.socket_keepalive = true;\n  }\n\n  for (var command in options.rename_commands) {\n    options.rename_commands[command.toLowerCase()] = options.rename_commands[command];\n  }\n\n  options.return_buffers = !!options.return_buffers;\n  options.detect_buffers = !!options.detect_buffers; // Override the detect_buffers setting if return_buffers is active and print a warning\n\n  if (options.return_buffers && options.detect_buffers) {\n    self.warn('WARNING: You activated return_buffers and detect_buffers at the same time. The return value is always going to be a buffer.');\n    options.detect_buffers = false;\n  }\n\n  if (options.detect_buffers) {\n    // We only need to look at the arguments if we do not know what we have to return\n    this.handle_reply = handle_detect_buffers_reply;\n  }\n\n  this.should_buffer = false;\n  this.max_attempts = options.max_attempts | 0;\n\n  if ('max_attempts' in options) {\n    self.warn('max_attempts is deprecated and will be removed in v.3.0.0.\\n' + 'To reduce the number of options and to improve the reconnection handling please use the new `retry_strategy` option instead.\\n' + 'This replaces the max_attempts and retry_max_delay option.');\n  }\n\n  this.command_queue = new Queue(); // Holds sent commands to de-pipeline them\n\n  this.offline_queue = new Queue(); // Holds commands issued but not able to be sent\n\n  this.pipeline_queue = new Queue(); // Holds all pipelined commands\n  // ATTENTION: connect_timeout should change in v.3.0 so it does not count towards ending reconnection attempts after x seconds\n  // This should be done by the retry_strategy. Instead it should only be the timeout for connecting to redis\n\n  this.connect_timeout = +options.connect_timeout || 3600000; // 60 * 60 * 1000 ms\n\n  this.enable_offline_queue = options.enable_offline_queue === false ? false : true;\n  this.retry_max_delay = +options.retry_max_delay || null;\n\n  if ('retry_max_delay' in options) {\n    self.warn('retry_max_delay is deprecated and will be removed in v.3.0.0.\\n' + 'To reduce the amount of options and the improve the reconnection handling please use the new `retry_strategy` option instead.\\n' + 'This replaces the max_attempts and retry_max_delay option.');\n  }\n\n  this.initialize_retry_vars();\n  this.pub_sub_mode = 0;\n  this.subscription_set = {};\n  this.monitoring = false;\n  this.message_buffers = false;\n  this.closing = false;\n  this.server_info = {};\n  this.auth_pass = options.auth_pass || options.password;\n  this.selected_db = options.db; // Save the selected db here, used when reconnecting\n\n  this.old_state = null;\n  this.fire_strings = true; // Determine if strings or buffers should be written to the stream\n\n  this.pipeline = false;\n  this.sub_commands_left = 0;\n  this.times_connected = 0;\n  this.buffers = options.return_buffers || options.detect_buffers;\n  this.options = options;\n  this.reply = 'ON'; // Returning replies is the default\n\n  this.create_stream(); // The listeners will not be attached right away, so let's print the deprecation message while the listener is attached\n\n  this.on('newListener', function (event) {\n    if (event === 'idle') {\n      this.warn('The idle event listener is deprecated and will likely be removed in v.3.0.0.\\n' + 'If you rely on this feature please open a new ticket in node_redis with your use case');\n    } else if (event === 'drain') {\n      this.warn('The drain event listener is deprecated and will be removed in v.3.0.0.\\n' + 'If you want to keep on listening to this event please listen to the stream drain event directly.');\n    } else if ((event === 'message_buffer' || event === 'pmessage_buffer' || event === 'messageBuffer' || event === 'pmessageBuffer') && !this.buffers && !this.message_buffers) {\n      if (this.reply_parser.name !== 'javascript') {\n        return this.warn('You attached the \"' + event + '\" listener without the returnBuffers option set to true.\\n' + 'Please use the JavaScript parser or set the returnBuffers option to true to return buffers.');\n      }\n\n      this.reply_parser.optionReturnBuffers = true;\n      this.message_buffers = true;\n      this.handle_reply = handle_detect_buffers_reply;\n    }\n  });\n}\n\nutil.inherits(RedisClient, EventEmitter);\nRedisClient.connection_id = 0;\n\nfunction create_parser(self) {\n  return new Parser({\n    returnReply: function (data) {\n      self.return_reply(data);\n    },\n    returnError: function (err) {\n      // Return a ReplyError to indicate Redis returned an error\n      self.return_error(err);\n    },\n    returnFatalError: function (err) {\n      // Error out all fired commands. Otherwise they might rely on faulty data. We have to reconnect to get in a working state again\n      // Note: the execution order is important. First flush and emit, then create the stream\n      err.message += '. Please report this.';\n      self.ready = false;\n      self.flush_and_error({\n        message: 'Fatal error encountert. Command aborted.',\n        code: 'NR_FATAL'\n      }, {\n        error: err,\n        queues: ['command_queue']\n      });\n      self.emit('error', err);\n      self.create_stream();\n    },\n    returnBuffers: self.buffers || self.message_buffers,\n    name: self.options.parser || 'javascript',\n    stringNumbers: self.options.string_numbers || false\n  });\n}\n/******************************************************************************\n\n    All functions in here are internal besides the RedisClient constructor\n    and the exported functions. Don't rely on them as they will be private\n    functions in node_redis v.3\n\n******************************************************************************/\n// Attention: the function name \"create_stream\" should not be changed, as other libraries need this to mock the stream (e.g. fakeredis)\n\n\nRedisClient.prototype.create_stream = function () {\n  var self = this; // Init parser\n\n  this.reply_parser = create_parser(this);\n\n  if (this.options.stream) {\n    // Only add the listeners once in case of a reconnect try (that won't work)\n    if (this.stream) {\n      return;\n    }\n\n    this.stream = this.options.stream;\n  } else {\n    // On a reconnect destroy the former stream and retry\n    if (this.stream) {\n      this.stream.removeAllListeners();\n      this.stream.destroy();\n    }\n    /* istanbul ignore if: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n\n\n    if (this.options.tls) {\n      this.stream = tls.connect(this.connection_options);\n    } else {\n      this.stream = net.createConnection(this.connection_options);\n    }\n  }\n\n  if (this.options.connect_timeout) {\n    this.stream.setTimeout(this.connect_timeout, function () {\n      // Note: This is only tested if a internet connection is established\n      self.retry_totaltime = self.connect_timeout;\n      self.connection_gone('timeout');\n    });\n  }\n  /* istanbul ignore next: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n\n\n  var connect_event = this.options.tls ? 'secureConnect' : 'connect';\n  this.stream.once(connect_event, function () {\n    this.removeAllListeners('timeout');\n    self.times_connected++;\n    self.on_connect();\n  });\n  this.stream.on('data', function (buffer_from_socket) {\n    // The buffer_from_socket.toString() has a significant impact on big chunks and therefore this should only be used if necessary\n    debug('Net read ' + self.address + ' id ' + self.connection_id); // + ': ' + buffer_from_socket.toString());\n\n    self.reply_parser.execute(buffer_from_socket);\n    self.emit_idle();\n  });\n  this.stream.on('error', function (err) {\n    self.on_error(err);\n  });\n  /* istanbul ignore next: difficult to test and not important as long as we keep this listener */\n\n  this.stream.on('clientError', function (err) {\n    debug('clientError occured');\n    self.on_error(err);\n  });\n  this.stream.once('close', function (hadError) {\n    self.connection_gone('close');\n  });\n  this.stream.once('end', function () {\n    self.connection_gone('end');\n  });\n  this.stream.on('drain', function () {\n    self.drain();\n  });\n\n  if (this.options.socket_nodelay) {\n    this.stream.setNoDelay();\n  } // Fire the command before redis is connected to be sure it's the first fired command\n\n\n  if (this.auth_pass !== undefined) {\n    this.ready = true; // Fail silently as we might not be able to connect\n\n    this.auth(this.auth_pass, function (err) {\n      if (err && err.code !== 'UNCERTAIN_STATE') {\n        self.emit('error', err);\n      }\n    });\n    this.ready = false;\n  }\n};\n\nRedisClient.prototype.handle_reply = function (reply, command) {\n  if (command === 'hgetall') {\n    reply = utils.reply_to_object(reply);\n  }\n\n  return reply;\n};\n\nRedisClient.prototype.cork = noop;\nRedisClient.prototype.uncork = noop;\n\nRedisClient.prototype.initialize_retry_vars = function () {\n  this.retry_timer = null;\n  this.retry_totaltime = 0;\n  this.retry_delay = 200;\n  this.retry_backoff = 1.7;\n  this.attempts = 1;\n};\n\nRedisClient.prototype.warn = function (msg) {\n  var self = this; // Warn on the next tick. Otherwise no event listener can be added\n  // for warnings that are emitted in the redis client constructor\n\n  process.nextTick(function () {\n    if (self.listeners('warning').length !== 0) {\n      self.emit('warning', msg);\n    } else {\n      console.warn('node_redis:', msg);\n    }\n  });\n}; // Flush provided queues, erroring any items with a callback first\n\n\nRedisClient.prototype.flush_and_error = function (error_attributes, options) {\n  options = options || {};\n  var aggregated_errors = [];\n  var queue_names = options.queues || ['command_queue', 'offline_queue']; // Flush the command_queue first to keep the order intakt\n\n  for (var i = 0; i < queue_names.length; i++) {\n    // If the command was fired it might have been processed so far\n    if (queue_names[i] === 'command_queue') {\n      error_attributes.message += ' It might have been processed.';\n    } else {\n      // As the command_queue is flushed first, remove this for the offline queue\n      error_attributes.message = error_attributes.message.replace(' It might have been processed.', '');\n    } // Don't flush everything from the queue\n\n\n    for (var command_obj = this[queue_names[i]].shift(); command_obj; command_obj = this[queue_names[i]].shift()) {\n      var err = new errorClasses.AbortError(error_attributes);\n\n      if (command_obj.error) {\n        err.stack = err.stack + command_obj.error.stack.replace(/^Error.*?\\n/, '\\n');\n      }\n\n      err.command = command_obj.command.toUpperCase();\n\n      if (command_obj.args && command_obj.args.length) {\n        err.args = command_obj.args;\n      }\n\n      if (options.error) {\n        err.origin = options.error;\n      }\n\n      if (typeof command_obj.callback === 'function') {\n        command_obj.callback(err);\n      } else {\n        aggregated_errors.push(err);\n      }\n    }\n  } // Currently this would be a breaking change, therefore it's only emitted in debug_mode\n\n\n  if (exports.debug_mode && aggregated_errors.length) {\n    var error;\n\n    if (aggregated_errors.length === 1) {\n      error = aggregated_errors[0];\n    } else {\n      error_attributes.message = error_attributes.message.replace('It', 'They').replace(/command/i, '$&s');\n      error = new errorClasses.AggregateError(error_attributes);\n      error.errors = aggregated_errors;\n    }\n\n    this.emit('error', error);\n  }\n};\n\nRedisClient.prototype.on_error = function (err) {\n  if (this.closing) {\n    return;\n  }\n\n  err.message = 'Redis connection to ' + this.address + ' failed - ' + err.message;\n  debug(err.message);\n  this.connected = false;\n  this.ready = false; // Only emit the error if the retry_stategy option is not set\n\n  if (!this.options.retry_strategy) {\n    this.emit('error', err);\n  } // 'error' events get turned into exceptions if they aren't listened for. If the user handled this error\n  // then we should try to reconnect.\n\n\n  this.connection_gone('error', err);\n};\n\nRedisClient.prototype.on_connect = function () {\n  debug('Stream connected ' + this.address + ' id ' + this.connection_id);\n  this.connected = true;\n  this.ready = false;\n  this.emitted_end = false;\n  this.stream.setKeepAlive(this.options.socket_keepalive);\n  this.stream.setTimeout(0);\n  this.emit('connect');\n  this.initialize_retry_vars();\n\n  if (this.options.no_ready_check) {\n    this.on_ready();\n  } else {\n    this.ready_check();\n  }\n};\n\nRedisClient.prototype.on_ready = function () {\n  var self = this;\n  debug('on_ready called ' + this.address + ' id ' + this.connection_id);\n  this.ready = true;\n\n  this.cork = function () {\n    self.pipeline = true;\n\n    if (self.stream.cork) {\n      self.stream.cork();\n    }\n  };\n\n  this.uncork = function () {\n    if (self.fire_strings) {\n      self.write_strings();\n    } else {\n      self.write_buffers();\n    }\n\n    self.pipeline = false;\n    self.fire_strings = true;\n\n    if (self.stream.uncork) {\n      // TODO: Consider using next tick here. See https://github.com/NodeRedis/node_redis/issues/1033\n      self.stream.uncork();\n    }\n  }; // Restore modal commands from previous connection. The order of the commands is important\n\n\n  if (this.selected_db !== undefined) {\n    this.internal_send_command(new Command('select', [this.selected_db]));\n  }\n\n  if (this.monitoring) {\n    // Monitor has to be fired before pub sub commands\n    this.internal_send_command(new Command('monitor', []));\n  }\n\n  var callback_count = Object.keys(this.subscription_set).length;\n\n  if (!this.options.disable_resubscribing && callback_count) {\n    // only emit 'ready' when all subscriptions were made again\n    // TODO: Remove the countdown for ready here. This is not coherent with all other modes and should therefore not be handled special\n    // We know we are ready as soon as all commands were fired\n    var callback = function () {\n      callback_count--;\n\n      if (callback_count === 0) {\n        self.emit('ready');\n      }\n    };\n\n    debug('Sending pub/sub on_ready commands');\n\n    for (var key in this.subscription_set) {\n      var command = key.slice(0, key.indexOf('_'));\n      var args = this.subscription_set[key];\n      this[command]([args], callback);\n    }\n\n    this.send_offline_queue();\n    return;\n  }\n\n  this.send_offline_queue();\n  this.emit('ready');\n};\n\nRedisClient.prototype.on_info_cmd = function (err, res) {\n  if (err) {\n    if (err.message === \"ERR unknown command 'info'\") {\n      this.on_ready();\n      return;\n    }\n\n    err.message = 'Ready check failed: ' + err.message;\n    this.emit('error', err);\n    return;\n  }\n  /* istanbul ignore if: some servers might not respond with any info data. This is just a safety check that is difficult to test */\n\n\n  if (!res) {\n    debug('The info command returned without any data.');\n    this.on_ready();\n    return;\n  }\n\n  if (!this.server_info.loading || this.server_info.loading === '0') {\n    // If the master_link_status exists but the link is not up, try again after 50 ms\n    if (this.server_info.master_link_status && this.server_info.master_link_status !== 'up') {\n      this.server_info.loading_eta_seconds = 0.05;\n    } else {\n      // Eta loading should change\n      debug('Redis server ready.');\n      this.on_ready();\n      return;\n    }\n  }\n\n  var retry_time = +this.server_info.loading_eta_seconds * 1000;\n\n  if (retry_time > 1000) {\n    retry_time = 1000;\n  }\n\n  debug('Redis server still loading, trying again in ' + retry_time);\n  setTimeout(function (self) {\n    self.ready_check();\n  }, retry_time, this);\n};\n\nRedisClient.prototype.ready_check = function () {\n  var self = this;\n  debug('Checking server ready state...'); // Always fire this info command as first command even if other commands are already queued up\n\n  this.ready = true;\n  this.info(function (err, res) {\n    self.on_info_cmd(err, res);\n  });\n  this.ready = false;\n};\n\nRedisClient.prototype.send_offline_queue = function () {\n  for (var command_obj = this.offline_queue.shift(); command_obj; command_obj = this.offline_queue.shift()) {\n    debug('Sending offline command: ' + command_obj.command);\n    this.internal_send_command(command_obj);\n  }\n\n  this.drain();\n};\n\nvar retry_connection = function (self, error) {\n  debug('Retrying connection...');\n  var reconnect_params = {\n    delay: self.retry_delay,\n    attempt: self.attempts,\n    error: error\n  };\n\n  if (self.options.camel_case) {\n    reconnect_params.totalRetryTime = self.retry_totaltime;\n    reconnect_params.timesConnected = self.times_connected;\n  } else {\n    reconnect_params.total_retry_time = self.retry_totaltime;\n    reconnect_params.times_connected = self.times_connected;\n  }\n\n  self.emit('reconnecting', reconnect_params);\n  self.retry_totaltime += self.retry_delay;\n  self.attempts += 1;\n  self.retry_delay = Math.round(self.retry_delay * self.retry_backoff);\n  self.create_stream();\n  self.retry_timer = null;\n};\n\nRedisClient.prototype.connection_gone = function (why, error) {\n  // If a retry is already in progress, just let that happen\n  if (this.retry_timer) {\n    return;\n  }\n\n  error = error || null;\n  debug('Redis connection is gone from ' + why + ' event.');\n  this.connected = false;\n  this.ready = false; // Deactivate cork to work with the offline queue\n\n  this.cork = noop;\n  this.uncork = noop;\n  this.pipeline = false;\n  this.pub_sub_mode = 0; // since we are collapsing end and close, users don't expect to be called twice\n\n  if (!this.emitted_end) {\n    this.emit('end');\n    this.emitted_end = true;\n  } // If this is a requested shutdown, then don't retry\n\n\n  if (this.closing) {\n    debug('Connection ended by quit / end command, not retrying.');\n    this.flush_and_error({\n      message: 'Stream connection ended and command aborted.',\n      code: 'NR_CLOSED'\n    }, {\n      error: error\n    });\n    return;\n  }\n\n  if (typeof this.options.retry_strategy === 'function') {\n    var retry_params = {\n      attempt: this.attempts,\n      error: error\n    };\n\n    if (this.options.camel_case) {\n      retry_params.totalRetryTime = this.retry_totaltime;\n      retry_params.timesConnected = this.times_connected;\n    } else {\n      retry_params.total_retry_time = this.retry_totaltime;\n      retry_params.times_connected = this.times_connected;\n    }\n\n    this.retry_delay = this.options.retry_strategy(retry_params);\n\n    if (typeof this.retry_delay !== 'number') {\n      // Pass individual error through\n      if (this.retry_delay instanceof Error) {\n        error = this.retry_delay;\n      }\n\n      this.flush_and_error({\n        message: 'Stream connection ended and command aborted.',\n        code: 'NR_CLOSED'\n      }, {\n        error: error\n      });\n      this.end(false);\n      return;\n    }\n  }\n\n  if (this.max_attempts !== 0 && this.attempts >= this.max_attempts || this.retry_totaltime >= this.connect_timeout) {\n    var message = 'Redis connection in broken state: ';\n\n    if (this.retry_totaltime >= this.connect_timeout) {\n      message += 'connection timeout exceeded.';\n    } else {\n      message += 'maximum connection attempts exceeded.';\n    }\n\n    this.flush_and_error({\n      message: message,\n      code: 'CONNECTION_BROKEN'\n    }, {\n      error: error\n    });\n    var err = new Error(message);\n    err.code = 'CONNECTION_BROKEN';\n\n    if (error) {\n      err.origin = error;\n    }\n\n    this.emit('error', err);\n    this.end(false);\n    return;\n  } // Retry commands after a reconnect instead of throwing an error. Use this with caution\n\n\n  if (this.options.retry_unfulfilled_commands) {\n    this.offline_queue.unshift.apply(this.offline_queue, this.command_queue.toArray());\n    this.command_queue.clear();\n  } else if (this.command_queue.length !== 0) {\n    this.flush_and_error({\n      message: 'Redis connection lost and command aborted.',\n      code: 'UNCERTAIN_STATE'\n    }, {\n      error: error,\n      queues: ['command_queue']\n    });\n  }\n\n  if (this.retry_max_delay !== null && this.retry_delay > this.retry_max_delay) {\n    this.retry_delay = this.retry_max_delay;\n  } else if (this.retry_totaltime + this.retry_delay > this.connect_timeout) {\n    // Do not exceed the maximum\n    this.retry_delay = this.connect_timeout - this.retry_totaltime;\n  }\n\n  debug('Retry connection in ' + this.retry_delay + ' ms');\n  this.retry_timer = setTimeout(retry_connection, this.retry_delay, this, error);\n};\n\nRedisClient.prototype.return_error = function (err) {\n  var command_obj = this.command_queue.shift();\n\n  if (command_obj.error) {\n    err.stack = command_obj.error.stack.replace(/^Error.*?\\n/, 'ReplyError: ' + err.message + '\\n');\n  }\n\n  err.command = command_obj.command.toUpperCase();\n\n  if (command_obj.args && command_obj.args.length) {\n    err.args = command_obj.args;\n  } // Count down pub sub mode if in entering modus\n\n\n  if (this.pub_sub_mode > 1) {\n    this.pub_sub_mode--;\n  }\n\n  var match = err.message.match(utils.err_code); // LUA script could return user errors that don't behave like all other errors!\n\n  if (match) {\n    err.code = match[1];\n  }\n\n  utils.callback_or_emit(this, command_obj.callback, err);\n};\n\nRedisClient.prototype.drain = function () {\n  this.emit('drain');\n  this.should_buffer = false;\n};\n\nRedisClient.prototype.emit_idle = function () {\n  if (this.command_queue.length === 0 && this.pub_sub_mode === 0) {\n    this.emit('idle');\n  }\n};\n\nfunction normal_reply(self, reply) {\n  var command_obj = self.command_queue.shift();\n\n  if (typeof command_obj.callback === 'function') {\n    if (command_obj.command !== 'exec') {\n      reply = self.handle_reply(reply, command_obj.command, command_obj.buffer_args);\n    }\n\n    command_obj.callback(null, reply);\n  } else {\n    debug('No callback for reply');\n  }\n}\n\nfunction subscribe_unsubscribe(self, reply, type) {\n  // Subscribe commands take an optional callback and also emit an event, but only the _last_ response is included in the callback\n  // The pub sub commands return each argument in a separate return value and have to be handled that way\n  var command_obj = self.command_queue.get(0);\n  var buffer = self.options.return_buffers || self.options.detect_buffers && command_obj.buffer_args;\n  var channel = buffer || reply[1] === null ? reply[1] : reply[1].toString();\n  var count = +reply[2]; // Return the channel counter as number no matter if `string_numbers` is activated or not\n\n  debug(type, channel); // Emit first, then return the callback\n\n  if (channel !== null) {\n    // Do not emit or \"unsubscribe\" something if there was no channel to unsubscribe from\n    self.emit(type, channel, count);\n\n    if (type === 'subscribe' || type === 'psubscribe') {\n      self.subscription_set[type + '_' + channel] = channel;\n    } else {\n      type = type === 'unsubscribe' ? 'subscribe' : 'psubscribe'; // Make types consistent\n\n      delete self.subscription_set[type + '_' + channel];\n    }\n  }\n\n  if (command_obj.args.length === 1 || self.sub_commands_left === 1 || command_obj.args.length === 0 && (count === 0 || channel === null)) {\n    if (count === 0) {\n      // unsubscribed from all channels\n      var running_command;\n      var i = 1;\n      self.pub_sub_mode = 0; // Deactivating pub sub mode\n      // This should be a rare case and therefore handling it this way should be good performance wise for the general case\n\n      while (running_command = self.command_queue.get(i)) {\n        if (SUBSCRIBE_COMMANDS[running_command.command]) {\n          self.pub_sub_mode = i; // Entering pub sub mode again\n\n          break;\n        }\n\n        i++;\n      }\n    }\n\n    self.command_queue.shift();\n\n    if (typeof command_obj.callback === 'function') {\n      // TODO: The current return value is pretty useless.\n      // Evaluate to change this in v.3 to return all subscribed / unsubscribed channels in an array including the number of channels subscribed too\n      command_obj.callback(null, channel);\n    }\n\n    self.sub_commands_left = 0;\n  } else {\n    if (self.sub_commands_left !== 0) {\n      self.sub_commands_left--;\n    } else {\n      self.sub_commands_left = command_obj.args.length ? command_obj.args.length - 1 : count;\n    }\n  }\n}\n\nfunction return_pub_sub(self, reply) {\n  var type = reply[0].toString();\n\n  if (type === 'message') {\n    // channel, message\n    if (!self.options.return_buffers || self.message_buffers) {\n      // backwards compatible. Refactor this in v.3 to always return a string on the normal emitter\n      self.emit('message', reply[1].toString(), reply[2].toString());\n      self.emit('message_buffer', reply[1], reply[2]);\n      self.emit('messageBuffer', reply[1], reply[2]);\n    } else {\n      self.emit('message', reply[1], reply[2]);\n    }\n  } else if (type === 'pmessage') {\n    // pattern, channel, message\n    if (!self.options.return_buffers || self.message_buffers) {\n      // backwards compatible. Refactor this in v.3 to always return a string on the normal emitter\n      self.emit('pmessage', reply[1].toString(), reply[2].toString(), reply[3].toString());\n      self.emit('pmessage_buffer', reply[1], reply[2], reply[3]);\n      self.emit('pmessageBuffer', reply[1], reply[2], reply[3]);\n    } else {\n      self.emit('pmessage', reply[1], reply[2], reply[3]);\n    }\n  } else {\n    subscribe_unsubscribe(self, reply, type);\n  }\n}\n\nRedisClient.prototype.return_reply = function (reply) {\n  if (this.monitoring) {\n    var replyStr;\n\n    if (this.buffers && Buffer.isBuffer(reply)) {\n      replyStr = reply.toString();\n    } else {\n      replyStr = reply;\n    } // If in monitor mode, all normal commands are still working and we only want to emit the streamlined commands\n\n\n    if (typeof replyStr === 'string' && utils.monitor_regex.test(replyStr)) {\n      var timestamp = replyStr.slice(0, replyStr.indexOf(' '));\n      var args = replyStr.slice(replyStr.indexOf('\"') + 1, -1).split('\" \"').map(function (elem) {\n        return elem.replace(/\\\\\"/g, '\"');\n      });\n      this.emit('monitor', timestamp, args, replyStr);\n      return;\n    }\n  }\n\n  if (this.pub_sub_mode === 0) {\n    normal_reply(this, reply);\n  } else if (this.pub_sub_mode !== 1) {\n    this.pub_sub_mode--;\n    normal_reply(this, reply);\n  } else if (!(reply instanceof Array) || reply.length <= 2) {\n    // Only PING and QUIT are allowed in this context besides the pub sub commands\n    // Ping replies with ['pong', null|value] and quit with 'OK'\n    normal_reply(this, reply);\n  } else {\n    return_pub_sub(this, reply);\n  }\n};\n\nfunction handle_offline_command(self, command_obj) {\n  var command = command_obj.command;\n  var err, msg;\n\n  if (self.closing || !self.enable_offline_queue) {\n    command = command.toUpperCase();\n\n    if (!self.closing) {\n      if (self.stream.writable) {\n        msg = 'The connection is not yet established and the offline queue is deactivated.';\n      } else {\n        msg = 'Stream not writeable.';\n      }\n    } else {\n      msg = 'The connection is already closed.';\n    }\n\n    err = new errorClasses.AbortError({\n      message: command + \" can't be processed. \" + msg,\n      code: 'NR_CLOSED',\n      command: command\n    });\n\n    if (command_obj.args.length) {\n      err.args = command_obj.args;\n    }\n\n    utils.reply_in_order(self, command_obj.callback, err);\n  } else {\n    debug('Queueing ' + command + ' for next server connection.');\n    self.offline_queue.push(command_obj);\n  }\n\n  self.should_buffer = true;\n} // Do not call internal_send_command directly, if you are not absolutly certain it handles everything properly\n// e.g. monitor / info does not work with internal_send_command only\n\n\nRedisClient.prototype.internal_send_command = function (command_obj) {\n  var arg, prefix_keys;\n  var i = 0;\n  var command_str = '';\n  var args = command_obj.args;\n  var command = command_obj.command;\n  var len = args.length;\n  var big_data = false;\n  var args_copy = new Array(len);\n\n  if (process.domain && command_obj.callback) {\n    command_obj.callback = process.domain.bind(command_obj.callback);\n  }\n\n  if (this.ready === false || this.stream.writable === false) {\n    // Handle offline commands right away\n    handle_offline_command(this, command_obj);\n    return false; // Indicate buffering\n  }\n\n  for (i = 0; i < len; i += 1) {\n    if (typeof args[i] === 'string') {\n      // 30000 seemed to be a good value to switch to buffers after testing and checking the pros and cons\n      if (args[i].length > 30000) {\n        big_data = true;\n        args_copy[i] = new Buffer(args[i], 'utf8');\n      } else {\n        args_copy[i] = args[i];\n      }\n    } else if (typeof args[i] === 'object') {\n      // Checking for object instead of Buffer.isBuffer helps us finding data types that we can't handle properly\n      if (args[i] instanceof Date) {\n        // Accept dates as valid input\n        args_copy[i] = args[i].toString();\n      } else if (args[i] === null) {\n        this.warn('Deprecated: The ' + command.toUpperCase() + ' command contains a \"null\" argument.\\n' + 'This is converted to a \"null\" string now and will return an error from v.3.0 on.\\n' + 'Please handle this in your code to make sure everything works as you intended it to.');\n        args_copy[i] = 'null'; // Backwards compatible :/\n      } else if (Buffer.isBuffer(args[i])) {\n        args_copy[i] = args[i];\n        command_obj.buffer_args = true;\n        big_data = true;\n      } else {\n        this.warn('Deprecated: The ' + command.toUpperCase() + ' command contains a argument of type ' + args[i].constructor.name + '.\\n' + 'This is converted to \"' + args[i].toString() + '\" by using .toString() now and will return an error from v.3.0 on.\\n' + 'Please handle this in your code to make sure everything works as you intended it to.');\n        args_copy[i] = args[i].toString(); // Backwards compatible :/\n      }\n    } else if (typeof args[i] === 'undefined') {\n      this.warn('Deprecated: The ' + command.toUpperCase() + ' command contains a \"undefined\" argument.\\n' + 'This is converted to a \"undefined\" string now and will return an error from v.3.0 on.\\n' + 'Please handle this in your code to make sure everything works as you intended it to.');\n      args_copy[i] = 'undefined'; // Backwards compatible :/\n    } else {\n      // Seems like numbers are converted fast using string concatenation\n      args_copy[i] = '' + args[i];\n    }\n  }\n\n  if (this.options.prefix) {\n    prefix_keys = commands.getKeyIndexes(command, args_copy);\n\n    for (i = prefix_keys.pop(); i !== undefined; i = prefix_keys.pop()) {\n      args_copy[i] = this.options.prefix + args_copy[i];\n    }\n  }\n\n  if (this.options.rename_commands && this.options.rename_commands[command]) {\n    command = this.options.rename_commands[command];\n  } // Always use 'Multi bulk commands', but if passed any Buffer args, then do multiple writes, one for each arg.\n  // This means that using Buffers in commands is going to be slower, so use Strings if you don't already have a Buffer.\n\n\n  command_str = '*' + (len + 1) + '\\r\\n$' + command.length + '\\r\\n' + command + '\\r\\n';\n\n  if (big_data === false) {\n    // Build up a string and send entire command in one write\n    for (i = 0; i < len; i += 1) {\n      arg = args_copy[i];\n      command_str += '$' + Buffer.byteLength(arg) + '\\r\\n' + arg + '\\r\\n';\n    }\n\n    debug('Send ' + this.address + ' id ' + this.connection_id + ': ' + command_str);\n    this.write(command_str);\n  } else {\n    debug('Send command (' + command_str + ') has Buffer arguments');\n    this.fire_strings = false;\n    this.write(command_str);\n\n    for (i = 0; i < len; i += 1) {\n      arg = args_copy[i];\n\n      if (typeof arg === 'string') {\n        this.write('$' + Buffer.byteLength(arg) + '\\r\\n' + arg + '\\r\\n');\n      } else {\n        // buffer\n        this.write('$' + arg.length + '\\r\\n');\n        this.write(arg);\n        this.write('\\r\\n');\n      }\n\n      debug('send_command: buffer send ' + arg.length + ' bytes');\n    }\n  }\n\n  if (command_obj.call_on_write) {\n    command_obj.call_on_write();\n  } // Handle `CLIENT REPLY ON|OFF|SKIP`\n  // This has to be checked after call_on_write\n\n  /* istanbul ignore else: TODO: Remove this as soon as we test Redis 3.2 on travis */\n\n\n  if (this.reply === 'ON') {\n    this.command_queue.push(command_obj);\n  } else {\n    // Do not expect a reply\n    // Does this work in combination with the pub sub mode?\n    if (command_obj.callback) {\n      utils.reply_in_order(this, command_obj.callback, null, undefined, this.command_queue);\n    }\n\n    if (this.reply === 'SKIP') {\n      this.reply = 'SKIP_ONE_MORE';\n    } else if (this.reply === 'SKIP_ONE_MORE') {\n      this.reply = 'ON';\n    }\n  }\n\n  return !this.should_buffer;\n};\n\nRedisClient.prototype.write_strings = function () {\n  var str = '';\n\n  for (var command = this.pipeline_queue.shift(); command; command = this.pipeline_queue.shift()) {\n    // Write to stream if the string is bigger than 4mb. The biggest string may be Math.pow(2, 28) - 15 chars long\n    if (str.length + command.length > 4 * 1024 * 1024) {\n      this.should_buffer = !this.stream.write(str);\n      str = '';\n    }\n\n    str += command;\n  }\n\n  if (str !== '') {\n    this.should_buffer = !this.stream.write(str);\n  }\n};\n\nRedisClient.prototype.write_buffers = function () {\n  for (var command = this.pipeline_queue.shift(); command; command = this.pipeline_queue.shift()) {\n    this.should_buffer = !this.stream.write(command);\n  }\n};\n\nRedisClient.prototype.write = function (data) {\n  if (this.pipeline === false) {\n    this.should_buffer = !this.stream.write(data);\n    return;\n  }\n\n  this.pipeline_queue.push(data);\n};\n\nObject.defineProperty(exports, 'debugMode', {\n  get: function () {\n    return this.debug_mode;\n  },\n  set: function (val) {\n    this.debug_mode = val;\n  }\n}); // Don't officially expose the command_queue directly but only the length as read only variable\n\nObject.defineProperty(RedisClient.prototype, 'command_queue_length', {\n  get: function () {\n    return this.command_queue.length;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'offline_queue_length', {\n  get: function () {\n    return this.offline_queue.length;\n  }\n}); // Add support for camelCase by adding read only properties to the client\n// All known exposed snake_case variables are added here\n\nObject.defineProperty(RedisClient.prototype, 'retryDelay', {\n  get: function () {\n    return this.retry_delay;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'retryBackoff', {\n  get: function () {\n    return this.retry_backoff;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'commandQueueLength', {\n  get: function () {\n    return this.command_queue.length;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'offlineQueueLength', {\n  get: function () {\n    return this.offline_queue.length;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'shouldBuffer', {\n  get: function () {\n    return this.should_buffer;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'connectionId', {\n  get: function () {\n    return this.connection_id;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'serverInfo', {\n  get: function () {\n    return this.server_info;\n  }\n});\n\nexports.createClient = function () {\n  return new RedisClient(unifyOptions.apply(null, arguments));\n};\n\nexports.RedisClient = RedisClient;\nexports.print = utils.print;\nexports.Multi = require('./lib/multi');\nexports.AbortError = errorClasses.AbortError;\nexports.RedisError = Parser.RedisError;\nexports.ParserError = Parser.ParserError;\nexports.ReplyError = Parser.ReplyError;\nexports.AggregateError = errorClasses.AggregateError; // Add all redis commands / node_redis api to the client\n\nrequire('./lib/individualCommands');\n\nrequire('./lib/extendedApi'); //enables adding new commands (for modules and new commands)\n\n\nexports.addCommand = exports.add_command = require('./lib/commands');","map":null,"metadata":{},"sourceType":"script"}